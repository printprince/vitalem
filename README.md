# Vitalem Microservices

Микросервисная архитектура для медицинской платформы Vitalem.

## Обзор проекта

Vitalem - это медицинская платформа, построенная на микросервисной архитектуре. Проект разделен на независимые сервисы, каждый из которых отвечает за свою область функциональности.

### Сервисы

- **Identity Service** - Аутентификация и авторизация пользователей
- **Logger Service** - Централизованное логирование для всех микросервисов

## Архитектура

Проект построен на микросервисной архитектуре с использованием следующих принципов:

- **Независимость сервисов** - Каждый сервис может быть разработан, развернут и масштабирован независимо
- **Единая точка логирования** - Все сервисы отправляют логи в централизованный Logger Service
- **Контейнеризация** - Все сервисы запускаются в Docker-контейнерах
- **Интеграция с ELK** - Для анализа и визуализации логов используется стек Elasticsearch, Kibana, Filebeat

### Взаимодействие между сервисами

```
┌─────────────────┐     HTTP     ┌─────────────────┐
│  Identity       │───────────-->│  Logger         │
│  Service        │   (логи)     │  Service        │
└─────────────────┘              └─────────────────┘
        │                                │
        │ HTTP                           │ HTTP
        │ (аутентификация)               │ (логи)
        ▼                                ▼
┌─────────────────┐              ┌─────────────────┐
│  Клиенты        │              │  Elasticsearch  │
│  (фронтенд)     │              │  (хранение)     │
└─────────────────┘              └─────────────────┘
                                         │
                                         │ HTTP
                                         ▼
                                  ┌─────────────────┐
                                  │  Kibana         │
                                  │  (визуализация) │
                                  └─────────────────┘
```

## Технологический стек

- **Языки программирования**: Go
- **Фреймворки**: Echo
- **Базы данных**: PostgreSQL
- **Логирование**: ELK Stack (Elasticsearch, Kibana, Filebeat)
- **Контейнеризация**: Docker, Docker Compose

## Запуск проекта

### Предварительные требования

- Docker и Docker Compose
- Go 1.21+

### Запуск с помощью Docker Compose

```bash
docker-compose up -d
```

### Доступные сервисы

- Identity Service: http://localhost:8801
- Logger Service: http://localhost:8802
- Kibana: http://localhost:5601
- Elasticsearch: http://localhost:9200

## Структура проекта

```
vitalem-microservices/
├── docker-compose.yml       # Конфигурация Docker Compose
├── identity_service/        # Сервис аутентификации и авторизации
│   ├── README.md            # Документация по Identity Service
│   ├── cmd/                 # Точка входа в приложение
│   ├── internal/            # Внутренние пакеты
│   ├── Dockerfile           # Инструкции для сборки Docker образа
│   └── config.yaml          # Файл конфигурации
├── logger_service/          # Сервис логирования
│   ├── README.md            # Документация по Logger Service
│   ├── cmd/                 # Точка входа в приложение
│   ├── internal/            # Внутренние пакеты
│   ├── pkg/                 # Библиотеки для использования в других сервисах
│   ├── Dockerfile           # Инструкции для сборки Docker образа
│   └── config.yaml          # Файл конфигурации
└── filebeat/
    └── filebeat.yml         # Конфигурация Filebeat
```

## Система централизованного логирования

Проект использует централизованную систему логирования на базе ELK-стека (Elasticsearch, Kibana, Filebeat) и собственного Logger Service.

### Архитектура системы логирования

```
┌────────────────┐
│                │
│  Микросервис   │──┐
│                │  │
└────────────────┘  │  HTTP API
                    │  (логи)
┌────────────────┐  │
│                │  │    ┌────────────────┐    ┌────────────────┐
│  Микросервис   │──┼───>│                │    │                │
│                │  │    │ Logger Service │───>│ Elasticsearch  │
└────────────────┘  │    │                │    │                │
                    │    └────────────────┘    └───────┬────────┘
┌────────────────┐  │                                  │
│                │  │                                  │
│  Микросервис   │──┘                                  │
│                │                          ┌──────────▼────────┐
└────────────────┘                          │                   │
                                            │      Kibana       │
                                            │                   │
                                            └───────────────────┘
```

### Преимущества подхода

1. **Минимум логов в контейнерах** - логи не накапливаются в контейнерах, а сразу отправляются в централизованное хранилище
2. **Единая точка доступа** - все логи доступны через Kibana с возможностью поиска и фильтрации
3. **Гибкая настройка уровней логирования** - можно настраивать, какие логи выводить в консоль, а какие отправлять в Logger Service
4. **Асинхронная отправка** - логи отправляются асинхронно, не блокируя основной поток выполнения

### Настройка логирования в сервисе

#### 1. Конфигурация в config.yaml

```yaml
logging:
  console_level: error  # Уровень логов для консоли (error, warn, info, debug, none)
  service_level: info   # Уровень логов для отправки в Logger Service
  service_url: http://logger_service:8802  # URL Logger Service
```

#### 2. Использование клиентской библиотеки

```go
import "github.com/printprince/vitalem/logger_service/pkg/logger"

// Инициализация клиента логгера
loggerClient := logger.NewClient(
    "http://logger_service:8802",  // URL Logger Service
    "your_service_name",           // Имя вашего сервиса
    "",                            // API ключ (опционально)
    logger.WithAsync(3),           // Запуск 3 воркеров для асинхронной отправки
    logger.WithTimeout(3*time.Second), // Таймаут HTTP запросов
)

// Отправка логов разных уровней
loggerClient.Debug("Отладочная информация", map[string]interface{}{"key": "value"})
loggerClient.Info("Информационное сообщение", map[string]interface{}{"user_id": 123})
loggerClient.Warn("Предупреждение", map[string]interface{}{"latency_ms": 500})
loggerClient.Error("Ошибка", map[string]interface{}{"error": err.Error()})

// Корректное завершение работы логгера
defer loggerClient.Close() // Дожидается отправки всех логов
```

#### 3. Настройка уровней логирования

Доступные уровни логирования:
- **debug** - отладочные сообщения (самый подробный уровень)
- **info** - информационные сообщения
- **warn** - предупреждения
- **error** - ошибки
- **none** - отключить вывод в консоль (только для console_level)

#### 4. Рекомендации по использованию

- Используйте уровень **error** для консоли в продакшене, чтобы минимизировать объем логов в контейнерах
- Используйте уровень **info** или **debug** для отправки в Logger Service, чтобы иметь полную информацию в Kibana
- Всегда добавляйте метаданные к логам для облегчения поиска и фильтрации
- Настраивайте корректное завершение работы логгера при выходе из приложения

### Просмотр логов в Kibana

1. Откройте Kibana по адресу http://localhost:5601
2. Перейдите в раздел "Discover"
3. Создайте индекс-паттерн "vitalem-logs-*"
4. Используйте поиск для фильтрации логов по сервису, уровню и другим полям

## Разработка

Каждый сервис содержит свою собственную документацию в соответствующем README.md файле с подробными инструкциями по разработке и использованию.

## Лицензия

MIT

